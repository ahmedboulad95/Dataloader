"use strict";

const jsforce = require("jsforce");
const utilities = require("./includes/utilities.js");
const logger = require("./includes/logger.js");
const dataDump = require("./includes/dataDump.js");

require('dotenv').config();

// Establish a connection to Salesforce
let loginOptions = { loginUrl: process.env.SF_DEST_ORG_URL };

let conn = new jsforce.Connection(loginOptions);
let recordObj = {};
let objMetadata = {};
let idMap = {};

let userId = "";

let order = require("./includes/objectOrder.js").order.slice();

let user = process.env.SF_DEST_ORG_USER;
let pass = process.env.SF_DEST_ORG_PASS;
let token = process.env.SF_DEST_ORG_TOKEN;

const logPath = "./logs/push.log";

logger.log(logPath, logger.debug.INFO, `Logging into ${loginOptions.loginUrl} as ${user}`);
console.log(user);
console.log(pass);
console.log(token);
conn.login(user, pass + token, function (err, userInfo) {
    if (err) {
        logger.log(logPath, logger.debug.ERROR, `Error logging in :: ${err}`);
        console.log("Error establishing connection. See logs for details");
        throw err;
    }

    userId = userInfo.id;
    logger.log(logPath, logger.debug.INFO, `Logged into ${conn.instanceUrl} as ${userInfo.id}`);

    dataDump.destroy(conn, userInfo.id)
        .then((status) => {
            logger.log(logPath, logger.debug.INFO, `Data dump destroy status :: ${status}`);

            if (status === 1) {
                throw "ABORT";
            }

            return utilities.readFile("./" + process.env.DATA_FOLDER_NAME + "/" + process.env.DATA_FILE_NAME)
        }).then((data) => {
            if (!data) {
                logger.log(logPath, logger.debug.ERROR, `Error reading file: ./${process.env.DATA_FOLDER_NAME}/${process.env.DATA_FILE_NAME} does not exist or is corrupted`);
                console.log(`Error reading file ${process.env.DATA_FILE_NAME}. See logs for details`);
                logger.flush(logPath);
                throw "Data file not found or empty";
            }

            logger.log(logPath, logger.debug.INFO, `./${process.env.DATA_FOLDER_NAME}/${process.env.DATA_FILE_NAME} opened successfully`);
            recordObj = JSON.parse(data);
            logger.log(logPath, logger.debug.INFO, `Reading object metadata information from ./${process.env.DATA_FOLDER_NAME}/${process.env.METADATA_FILE_NAME}`);
            return utilities.readFile("./" + process.env.DATA_FOLDER_NAME + "/" + process.env.METADATA_FILE_NAME);
        }).then((data) => {
            if (!data) {
                logger.log(logPath, logger.debug.ERROR, `Error reading file: ./${process.env.DATA_FOLDER_NAME}/${process.env.METADATA_FILE_NAME} does not exist or is corrupted`);
                console.log(`Error reading file ${process.env.METADATA_FILE_NAME}. See logs for details`);
                logger.flush(logPath);
                throw "Metadata file not found or empty";
            }

            logger.log(logPath, logger.debug.INFO, `./${process.env.DATA_FOLDER_NAME}/${process.env.METADATA_FILE_NAME} opened successfully`);
            objMetadata = JSON.parse(data);

            let counter = 0;
            let keys = Object.keys(recordObj);

            logger.log(logPath, logger.debug.INFO, `Objects to insert :: ${keys.toString()}`);

            uploadDataSet(order.shift(), order).then(() => {
                logger.log(logPath, logger.debug.INFO, "All records inserted");
                console.log("Upload complete");
                updateIds();
                console.dir(idMap);
                return handleUpdate();
            }).then(() => {
                logger.log(logPath, logger.debug.INFO, "All record references updated");
                console.log("Update complete");
                logger.flush(logPath);
                conn.logout((err) => {
                    if (err) {
                        logger.log(logPath, logger.debug.ERROR, `Error logging out :: ${err}`);
                    } else {
                        logger.log(logPath, logger.debug.INFO, "Successfully closed the connection to Salesforce");
                        logger.flush(logPath);
                    }
                    process.exit();
                });
            });
        }).catch((err) => {
            if (err === "ABORT") {
                logger.log(logPath, logger.debug.INFO, "Operation aborted");
                console.log("Operation aborted");
                process.exit();
            } else {
                logger.log(logPath, logger.debug.ERROR, `Error in execution :: ${err}`);
                console.log("Error in execution. See logs for details");
            }
        });
});

/**
 * @description updates all record ids with the new ids generated by salesforce on insert
 */
function updateIds() {
    let keys = Object.keys(recordObj);
    for (let i = 0; i < keys.length; i++) {
        let currentObj = keys[i];
        logger.log(logPath, logger.debug.INFO, `Updating Ids for ${currentObj}`);
        let metadata = objMetadata[currentObj];
        for (let j = 0; j < recordObj[currentObj].length; j++) {
            for (let k = 0; k < metadata.fields.length; k++) {
                if (metadata.fields[k].referenceTo.length > 0 && idMap[recordObj[currentObj][j][metadata.fields[k].name]]) {
                    logger.log(logPath, logger.debug.INFO, `Updating reference field ${currentObj}.${metadata.fields[k].name}`);
                    recordObj[currentObj][j][metadata.fields[k].name] = idMap[recordObj[currentObj][j][metadata.fields[k].name]];
                }
            }
        }
    }
}

/**
 * @description recursively inserts records until all sobjects have been inserted
 * @param {String} current - current sobject being insert
 * @param {Array} queue - list of remaining sobjects to insert
 */
function uploadDataSet(current, queue) {
    return insertRecords(recordObj[current], current).then(() => {
        let current = queue.shift();
        if (current) {
            return uploadDataSet(current, queue);
        } else {
            return;
        }
    }).catch((err) => {
        logger.log(logPath, logger.debug.ERROR, `Error inserting :: ${err}`);
        console.log(`Error inserting :: ${err}`)
        let current = queue.shift();
        if (current) {
            return uploadDataSet(current, queue);
        } else {
            return;
        }
    });
}

/**
 * @description inserts records into salesforce
 * @param {Array} records - list of records to insert
 * @param {String} objectName - name of sobject
 */
function insertRecords(records, objectName) {
    return new Promise((resolve, reject) => {
        if (!objectName) {
            reject("Object name is required");
        }

        if (!records) {
            console.log(`No records for ${objectName}`);
            resolve();
        }

        logger.log(logPath, logger.debug.INFO, `Inserting ${objectName}`);
        console.log(`Inserting ${objectName}`);

        /*for(let i = 0; i < records.length; i++) {
            records[i].OwnerId = userId;
        }*/

        conn.sobject(objectName).create(records, { allowRecursive: true }, (err, rets) => {
            if (err) reject(err);

            /*console.log(rets.length);
            console.log(objectName);
            rets.forEach((element => {
                console.dir(element);
            }));*/
            if(rets) {
                rets.forEach((element => {
                    console.dir(element);
                }));
                for (let i = 0; i < rets.length; i++) {
                    idMap[records[i].Id] = rets[i].id;
                    recordObj[objectName][i].Id = rets[i].id;
                }
            }

            updateIds();

            resolve();
        });
    });
}

/**
 * @description updates records for all sobjects
 */
function handleUpdate() {
    return new Promise((resolve, reject) => {
        let newKeys = Object.keys(recordObj);
        let counter = 0;
        for (let j = 0; j < newKeys.length; j++) {
            updateRecords(recordObj[newKeys[j]], newKeys[j]).then(() => {
                if (counter === newKeys.length - 1) {
                    resolve();
                }
                counter++;
            }).catch((err) => {
                logger.log(logPath, logger.debug.ERROR, `Error updating ${newKeys[j]} :: ${err}`);
                console.log(`Error updating :: ${err}`);
                reject(err);
            });
        }
    });
}

/**
 * @description updates a set of records for a single sobject
 * @param {Array} records - list of records to be updated
 * @param {String} objectName - sobject name
 */
function updateRecords(records, objectName) {
    return new Promise((resolve, reject) => {
        console.log(`Updating ${objectName}`);
        //console.log(records);
        conn.sobject(objectName).update(records, { allowRecursive: true }, (err, ret) => {
            if (err) reject(err);
            else resolve();
        });
    });
}

